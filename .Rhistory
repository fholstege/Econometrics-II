# Packes required for subsequent analysis. P_load ensures these will be installed and loaded.
if (!require("pacman")) install.packages("pacman")
library(tidyquant) # download Yahoo finance data
library(pracma) #
library(tidyverse) # tables
#library(PerformanceAnalytics) # returns
#library(matlib) # matrix
#library(timetk) # To manipulate the data series
# Get data
tickers = c("GS", "MCD", "DOW", "CAT", "MRK", "CVX", "VZ", "MSFT", "AMGN", "CSCO", "BA", "PG", "JPM", "WBA",
"DIS", "KO", "MMM", "AXP", "WMT", "JNJ", "HON", "V", "NKE", "AAPL", "CRM", "HD", "TRV", "UNH", "INTC", "IBM")
getSymbols(tickers, from = '2019-12-31',
to = "2021-01-01", warnings = FALSE,
auto.assign = TRUE)
getSymbols("DJI", from = '2020-01-01',
to = "2021-01-01", warnings = FALSE,
auto.assign = TRUE)
# Get adjusted prices only
prices <- merge(GS, MCD, DOW, CAT, MRK, CVX, VZ, MSFT, AMGN, CSCO, BA, PG, JPM, WBA,
DIS, KO, MMM, AXP, WMT, JNJ, HON, V, NKE, AAPL, CRM, HD, TRV, UNH, INTC, IBM)
prices <- prices[, grepl("Adjusted", names(prices))]
rm(GS, MCD, DOW, CAT, MRK, CVX, VZ, MSFT, AMGN, CSCO, BA, PG, JPM, WBA,
DIS, KO, MMM, AXP, WMT, JNJ, HON, V, NKE, AAPL, CRM, HD, TRV, UNH, INTC, IBM)
# Calculate returns
returns <- Return.calculate(xts(prices), method="discrete")
returns <- returns[-1,]
colnames(returns) <- c("GS", "MCD", "DOW", "CAT", "MRK", "CVX", "VZ", "MSFT", "AMGN", "CSCO", "BA", "PG", "JPM", "WBA",
"DIS", "KO", "MMM", "AXP", "WMT", "JNJ", "HON", "V", "NKE", "AAPL", "CRM", "HD", "TRV", "UNH", "INTC", "IBM")
# Do the same for DJI index
DJI <- DJI[, grepl("Adjusted", names(DJI))]
DJI <- Return.calculate(xts(DJI), method="discrete")
DJI <- DJI[-1,]
DJI <- data.frame(var(na.omit(DJI)), sd(na.omit(DJI)))
# ----------------------------
# Calculate the mean variance frontier
mean_returns <- colMeans(returns[sapply(returns, is.numeric)])
cov_matr <- var(returns)
sds <- apply(returns, 2, sd)
cov_means <- data.frame(mean_returns, sds)
one_vector <- ones(30, 1)
returns_bar <- seq(-0.01, 0.01, 0.0001)
A <- t(one_vector) %*% inv(cov_matr) %*% mean_returns
B <- t(mean_returns) %*% inv(cov_matr) %*% mean_returns
C <- t(one_vector) %*% inv(cov_matr) %*% one_vector
D <- (B*C) - A^2
min_sigma <- sqrt((1/C) + (C/D)*(returns_bar-(A/C))^2)
portfolio <- data.frame(returns_bar, min_sigma)
#------------------------------
# Plot the mean-variance frontier with all stocks
ggplot(data = cov_means, aes(x = sds, y = mean_returns)) +
geom_point() +
geom_path(data = portfolio, aes(x = min_sigma, y = returns_bar), colour = "red") #+
geom_point(data=DJI, colour="red") +
#geom_text(data=DJI, label="DJI") +
labs(title = "") +
theme_bw()
min_sigma <- sqrtsqrt((1/C) + (C/D)*(returns_bar-(A/C))^2))
portfolio <- data.frame(returns_bar, min_sigma)
#------------------------------
# Plot the mean-variance frontier with all stocks
ggplot(data = cov_means, aes(x = sds, y = mean_returns)) +
geom_point() +
geom_path(data = portfolio, aes(x = min_sigma, y = returns_bar), colour = "red") #+
min_sigma <- sqrt(sqrt((1/C) + (C/D)*(returns_bar-(A/C))^2))
portfolio <- data.frame(returns_bar, min_sigma)
#------------------------------
# Plot the mean-variance frontier with all stocks
ggplot(data = cov_means, aes(x = sds, y = mean_returns)) +
geom_point() +
geom_path(data = portfolio, aes(x = min_sigma, y = returns_bar), colour = "red") #+
min_sigma <- sqrt((1/C) + (C/D)*(returns_bar-(A/C))^2)
portfolio <- data.frame(returns_bar, min_sigma)
#------------------------------
# Plot the mean-variance frontier with all stocks
ggplot(data = cov_means, aes(x = sds, y = mean_returns)) +
geom_point() +
geom_path(data = portfolio, aes(x = min_sigma, y = returns_bar), colour = "red") #+
returns_bar <- seq(-0.02, 0.02, 0.0001)
A <- t(one_vector) %*% inv(cov_matr) %*% mean_returns
B <- t(mean_returns) %*% inv(cov_matr) %*% mean_returns
C <- t(one_vector) %*% inv(cov_matr) %*% one_vector
D <- (B*C) - A^2
min_sigma <- sqrt((1/C) + (C/D)*(returns_bar-(A/C))^2)
portfolio <- data.frame(returns_bar, min_sigma)
#------------------------------
# Plot the mean-variance frontier with all stocks
ggplot(data = cov_means, aes(x = sds, y = mean_returns)) +
geom_point() +
geom_path(data = portfolio, aes(x = min_sigma, y = returns_bar), colour = "red") #+
returns_bar <- seq(-0.03, 0.03, 0.0001)
A <- t(one_vector) %*% inv(cov_matr) %*% mean_returns
B <- t(mean_returns) %*% inv(cov_matr) %*% mean_returns
C <- t(one_vector) %*% inv(cov_matr) %*% one_vector
D <- (B*C) - A^2
min_sigma <- sqrt((1/C) + (C/D)*(returns_bar-(A/C))^2)
portfolio <- data.frame(returns_bar, min_sigma)
#------------------------------
# Plot the mean-variance frontier with all stocks
ggplot(data = cov_means, aes(x = sds, y = mean_returns)) +
geom_point() +
geom_path(data = portfolio, aes(x = min_sigma, y = returns_bar), colour = "red") #+
returns_bar <- seq(-0.04, 0.04, 0.0001)
A <- t(one_vector) %*% inv(cov_matr) %*% mean_returns
B <- t(mean_returns) %*% inv(cov_matr) %*% mean_returns
C <- t(one_vector) %*% inv(cov_matr) %*% one_vector
D <- (B*C) - A^2
min_sigma <- sqrt((1/C) + (C/D)*(returns_bar-(A/C))^2)
portfolio <- data.frame(returns_bar, min_sigma)
#------------------------------
# Plot the mean-variance frontier with all stocks
ggplot(data = cov_means, aes(x = sds, y = mean_returns)) +
geom_point() +
geom_path(data = portfolio, aes(x = min_sigma, y = returns_bar), colour = "red") #+
returns_bar <- seq(-0.05, 0.05, 0.0001)
A <- t(one_vector) %*% inv(cov_matr) %*% mean_returns
B <- t(mean_returns) %*% inv(cov_matr) %*% mean_returns
C <- t(one_vector) %*% inv(cov_matr) %*% one_vector
D <- (B*C) - A^2
min_sigma <- sqrt((1/C) + (C/D)*(returns_bar-(A/C))^2)
portfolio <- data.frame(returns_bar, min_sigma)
#------------------------------
# Plot the mean-variance frontier with all stocks
ggplot(data = cov_means, aes(x = sds, y = mean_returns)) +
geom_point() +
geom_path(data = portfolio, aes(x = min_sigma, y = returns_bar), colour = "red") #+
get_MDE <- function(alpha, power, p){
t_alpha <- qt(1-alpha/2, n - n_coef)
t_q <- qt(1-power, n - n_coef)
sigma2 <- perc_pass* (1- perc_pass)
MDE <- (t_alpha - t_q) * sqrt(1/(p*(1-p))) * sqrt(sigma2/n)
return(MDE)
}
size <- (((1.96 - (-0.524))/0.1)^2) * (0.5*0.5)/(0.5*(1-0.5)
size
(((1.96 - (-0.524))/0.1)^2) * (0.5*0.5)/(0.5*(1-0.5)
((1.96 - (-0.524))/0.1)^2) * (0.5*0.5)/(0.5*(1-0.5)
(((1.96 + 0.524)/0.1)^2) * (0.5*0.5)/(0.5*(1-0.5)
(((1.96 + 0.524)/0.1)^2) * (0.5*0.5)/(0.5*(1-0.5))
round((((1.96 + 0.524)/0.1)^2) * (0.5*0.5)/(0.5*(1-0.5)), 0)
# get size, given mde
get_size_givenMDE <- function(MDE, fAlpha, fPower, p, Sigma2){
# get t values
t_alpha <- qnorm(1-fAlpha/2, 0,Sigma2)
t_q <-qnorm(1-fPower, 0,Sigma2)
# get the MDE
size <- (((t_alpha - t_q)/MDE)^2) * sigma2/(p*(1-p))
size <- round(size, 0)
return(size)
}
# get parameters for power calculation
MDE = 0.1
fAlpha = 0.05
fPower = 0.7
p = 0.5
sigma2 <- p* (1- p)
# determine size
size = get_size_givenMDE(MDE, fAlpha, fPower, p, sigma2)
size
# get size, given mde
get_size_givenMDE <- function(MDE, fAlpha, fPower, p, Sigma2){
# get t values
t_alpha <- qnorm(1-fAlpha/2, 0,Sigma2)
t_q <-qnorm(1-fPower, 0,Sigma2)
# get the MDE
size <- (((t_alpha - t_q)/MDE)^2) * sigma2/(p*(1-p))
size <- round(size, 0)
return(size)
}
# get parameters for power calculation
MDE = 0.1
fAlpha = 0.05
fPower = 0.7
p = 0.5
sigma2 <- p* (1- p)
# determine size
size = get_size_givenMDE(MDE, fAlpha, fPower, p, sigma2)
size
# (ii): determine size with non-compliers
round((((1.96 + 0.524)/((0.8)*0.1))^2) * (0.5*0.5)/(0.5*(1 - 0.5)), 0)
#-------------------
# Problem 2
# (i): determine size
round((((1.96 + 0.524)/0.1)^2) * (0.5*0.5)/(0.5*(1 - 0.5)), 0)
# (ii): determine size with non-compliers
round((((1.96 + 0.524)/((0.8)*0.1))^2) * (0.5*0.5)/(0.5*(1 - 0.5)), 0)
libraty(rio)
library(rio)
#-----------------
# Problem 3
dfFlu <- import("Data/FluData.dta")
setwd("~/Documents/Econometrics-II")
#-----------------
# Problem 3
dfFlu <- import("Data/FluData.dta")
#-----------------
# Problem 3
setwd("~/Documents/Econometrics-II")
dfFlu <- import("Data/FluData.dta")
#-----------------
# Problem 3
setwd("~/Documents/Econometrics-II")
dfFlu <- import("Data/FluData.dta")
View(dfFlu)
dfFlu_treatment <- dfFlu[dfFlu$TreatGroup == 1,]
dfFlu_control <- dfFlu[dfFlu$TreatGroup == 0,]
# percentage that got the flu in the treatment group (got flu shot)
p_flu <- sum(dfFlu_control$Flu)/nrow(dfFlu_control)
# estimate the sigma2
sigma2_flu <- p*(1-p)
# percentage that got the flu in the treatment group (got flu shot)
p <- sum(dfFlu_control$Flu)/nrow(dfFlu_control)
# estimate the sigma2
sigma2_flu <- p*(1-p)
sigma2_flu
# -------- We need to use CONTROL and not TREATMENT group
# percentage that got the flu in the control group (got flu shot)
p <- sum(dfFlu_control$Flu)/nrow(dfFlu_control)
# estimate the sigma2
sigma2 <- p*(1-p)
sigma2
#---------------
# (i)
round((((1.96 + 0.84)/0.05)^2) * (sigma2)/(0.8*(1 - 0.8)), 0)
dfFlu <- read.dta13("Data/FluData.dta")
pacman::p_load(plm,
Formula,
car,
clubSandwich,
lmtest,
foreign,
tidyverse,
xtable,
stargazer,
AER)
# get size, given mde
get_size_givenMDE <- function(MDE, fAlpha, fPower, p, Sigma2){
# get t values
t_alpha <- qnorm(1-fAlpha/2, 0,Sigma2)
t_q <-qnorm(1-fPower, 0,Sigma2)
# get the MDE
size <- (((t_alpha - t_q)/MDE)^2) * sigma2/(p*(1-p))
size <- round(size, 0)
return(size)
}
# get parameters for power calculation
MDE = 0.1
fAlpha = 0.05
fPower = 0.7
p = 0.5
sigma2 <- p* (1- p)
# determine size
size = get_size_givenMDE(MDE, fAlpha, fPower, p, sigma2)
# define percentage that does not comply
perc_nonComply <- 0.2
# new size, given rate of non-compliance
new_size = (1/(1-perc_nonComply))*size
# get data on flu shots, divide in treatment and control
dfFlu <- read.dta13("Data/FluData.dta")
# get data on flu shots, divide in treatment and control
dfFlu <- import("Data/FluData.dta")
setwd("~/Documents/Econometrics-II")
# get data on flu shots, divide in treatment and control
dfFlu <- import("Data/FluData.dta")
dfFlu_treatment <- dfFlu[dfFlu$TreatGroup == 1,]
dfFlu_control <- dfFlu[dfFlu$TreatGroup == 0,]
# percentage that got the flu in the treatment group (got flu shot)
p_flu <- sum(dfFlu_treatment$Flu)/nrow(dfFlu_treatment)
# estimate the sigma2
sigma2_flu <- p*(1-p)
# size of the experiment, given p and sigma2
size_flu <- get_size_givenMDE(0.05, fAlpha, fPower, p_flu, sigma2_flu)
size_flu
sigma2
sigma2 <- p* (1- p)
sigma2
#---------------
# (i)
round((((1.96 + 0.84)/0.05)^2) * (sigma2)/(0.8*(1 - 0.8)), 0)
round((((1.96 + 0.84)/0.05)^2) * (sigma2)/(0.8*(1 - 0.8)), 0)
round((((1.96 + 0.84)/-0.05)^2) * (sigma2)/(0.8*(1 - 0.8)), 0)
round((((1.96 + 0.84)/0.05)^2) * (sigma2)/(0.8*(1 - 0.8)), 0)
sigma2 <- p*(1-p)
round((((1.96 + 0.84)/0.05)^2) * (sigma2)/(0.8*(1 - 0.8)), 0)
# -------- We need to use CONTROL and not TREATMENT group
# (i) Calculate variance for the control group AND size
p <- sum(dfFlu_control$Flu)/nrow(dfFlu_control)
sigma2 <- p*(1-p)
round((((1.96 + 0.84)/0.05)^2) * (sigma2)/(0.8*(1 - 0.8)), 0)
# (ii) Fraction of actual recevers of the flu shot
p_actual <- sum(dfFlu_treatment$Treatment)/nrow(dfFlu_treatment)
p_actual
get_size_givenMDE <- function(MDE, fAlpha, fPower, p, Sigma2){
# get t values
t_alpha <- qnorm(1-fAlpha/2, 0,Sigma2)
t_q <-qnorm(1-fPower, 0,Sigma2)
# get the MDE
size <- (((t_alpha - t_q)/MDE)^2) * sigma2/(p*(1-p))
size <- round(size, 0)
return(size)
}
# get parameters for power calculation
MDE = 0.1
fAlpha = 0.05
fPower = 0.7
p = 0.5
sigma2 <- p* (1- p)
# determine size
size = get_size_givenMDE(MDE, fAlpha, fPower, p, sigma2)
# define percentage that does not comply
perc_nonComply <- 0.2
# new size, given rate of non-compliance
new_size = (1/(1-perc_nonComply))*size
size
new_size
dfFlu_actualTreatment <- dfFlu_treatment[dfFlu_treatment$Treatment == 1,]
perc_comply_flu <- nrow(dfFlu_actualTreatment)/nrow(dfFlu_treatment)
perc_comply_flu
round((((1.96 + 0.84)/((p_actual)*0.05))^2) * (0.5*0.5)/(0.8*(1 - 0.8)), 0)
round((((1.96 + 0.84)/0.05)^2) * (sigma2)/(0.8*(1 - 0.8)), 0)
# (ii) Fraction of actual recevers of the flu shot
p_actual <- sum(dfFlu_treatment$Treatment)/nrow(dfFlu_treatment)
round((((1.96 + 0.84)/((p_actual)*0.05))^2) * (0.5*0.5)/(0.8*(1 - 0.8)), 0)
dfFlu_treatment <- dfFlu[dfFlu$TreatGroup == 1,]
dfFlu_control <- dfFlu[dfFlu$TreatGroup == 0,]
# percentage that got the flu in the treatment group (got flu shot)
p_flu <- sum(dfFlu_treatment$Flu)/nrow(dfFlu_treatment)
# estimate the sigma2
sigma2_flu <- p*(1-p)
# size of the experiment, given p and sigma2
size_flu <- get_size_givenMDE(0.05, fAlpha, fPower, p_flu, sigma2_flu)
# get df with group that actually got the treatment
dfFlu_actualTreatment <- dfFlu_treatment[dfFlu_treatment$Treatment == 1,]
perc_comply_flu <- nrow(dfFlu_actualTreatment)/nrow(dfFlu_treatment)
# get new size given the rate that did not get treatment
new_size_flu = (1/(perc_comply_flu)^2)*size_flu
new_size_flu
View(dfFlu)
# (iii)
dfFlu$status <- ifelse(dfFlu$TreatGroup = 0, "Control", ifelse(dfFlu$Treatment = 1, "Treated", "Untreated"))
# (iii)
dfFlu$status <- ifelse(dfFlu$TreatGroup == 0, "Control", ifelse(dfFlu$Treatment == 1, "Treated", "Untreated"))
table(dfFlu$status)
2494     + 6739   +   3350
